#version 450

#define INFINITY 1.0f / 0.0f
#define EPSILON 0.001f
#define TRIANGLES_NUM 1

struct AmbientLight {
    float bright;
};

struct DirectionalLight {
    float bright, maxT;
    vec3 position;
};

struct PointLight {
    float bright, maxT, shininess;
    vec4 position;
};

struct Sphere {
    float radius, specular, reflective;
    vec4 center;
    vec4 color;
};

struct Triangle {
    bool single_side;
    float specular, reflective;
    vec4 A,B,C;
    vec4 color;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

struct Hit {
    float t;
    bool is_triangle;
    Sphere sphere;
    Triangle triangle;
};

struct Camera {
    vec3 position;
    mat4 rotation;
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (binding = 0, rgba8) uniform image2D colorBuffer;
layout (std140, binding = 1) readonly buffer SpheresBuffer {
    Sphere spheres[];
};
layout (binding = 2) uniform SceneBuffer {
    int spheres_num, triangles_num, point_lights_num, aa;
    Camera camera;
} scene;
layout (std140, binding = 3) readonly buffer PointLightsBuffer {
    PointLight point_lights[];
};
layout (std140, binding = 4) readonly buffer TrianglesBuffer {
    Triangle triangles[];
};

vec3 perPixel(int x, int y);

void main() {
    ivec2 screen_pos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

    vec3 color = perPixel(screen_pos.x, screen_pos.y);

    imageStore(colorBuffer, screen_pos, vec4(color, 1.0));
}

vec2 getSphereHit(Ray ray, Sphere sphere) {
    vec3 oc = ray.origin - sphere.center.xyz;

    float a = dot(ray.direction, ray.direction);
    float b = 2.0 * dot(oc, ray.direction);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b*b - 4.0*a*c;

    if (discriminant > 0) {
        float x1 = (-b + sqrt(discriminant)) / (2 * a);
        float x2 = (-b - sqrt(discriminant)) / (2 * a);

        return vec2(x1, x2);
    }

    return vec2(INFINITY, INFINITY);
}

vec2 getTriangleHit(Ray ray, Triangle triangle) {
    vec3 e1 = (triangle.B - triangle.A).xyz;
    vec3 e2 = (triangle.C - triangle.A).xyz;

    vec3 pvec = cross(ray.direction, e2);
    float det = dot(e1, pvec);

    if (triangle.single_side && det < EPSILON) {
        return vec2(INFINITY, INFINITY);
    }
    else if (det < EPSILON && det > -EPSILON) {
        return vec2(INFINITY, INFINITY);
    }

    float inv_det = 1.0f / det;

    vec3 tvec = ray.origin - triangle.A.xyz;
    float v = inv_det * dot(tvec, pvec);

    if (v < 0.0f || v > 1.0f) {
        return vec2(INFINITY, INFINITY);
    }

    vec3 qvec = cross(tvec, e1);
    float w = inv_det * dot(ray.direction, qvec);

    if (w < 0.0f || w + v > 1.0f) {
        return vec2(INFINITY, INFINITY);
    }

    float t = inv_det * dot(e2, qvec);

    if (t > EPSILON) return vec2(t, t);

    return vec2(INFINITY, INFINITY);
}

Ray getRay(float x, float y)
{
    ivec2 screen_size = imageSize(colorBuffer);
    float fov = 60;

    vec3 direction = vec3(x * 1.f / screen_size.x, y * 1.f / screen_size.y, -1.0f);

    direction.x = direction.x * 2.0f - 1.0f;
    direction.y = 1.0f - 2.0f * direction.y;

    float aspect_ratio = float(screen_size.x) / float(screen_size.y);
    float fov_radians = radians(fov);
    float tan_half_fov = tan(fov_radians / 2.0f);
    
    direction.x = direction.x * aspect_ratio * tan_half_fov;
    direction.y = direction.y * tan_half_fov;

    vec4 rotated_direction = scene.camera.rotation * vec4(direction, 1.0f);

    Ray ray;
    ray.origin = scene.camera.position;
    ray.direction = normalize(rotated_direction.xyz);

    return ray;
}

vec3 getSkyColor(Ray ray)
{
    vec3 base = vec3(0.4, 0.9, 1.0);

    float pos = 0.5 * (ray.direction.y + 1.0);

    return (pos * base) + ((1 - pos) * vec3(1.0, 1.0, 1.0));
}

vec3 GetPointLightVector(vec3 point, PointLight light) {
    return normalize(light.position.xyz - point);
}

Hit getIntersection(Ray ray, float min_t, float max_t) {
	Hit intersection;
    intersection.t = INFINITY;
    intersection.is_triangle = false;

	for (int i = 0; i < scene.spheres_num; i++) {
		Sphere sphere = spheres[i];

		vec2 sphere_hit = getSphereHit(ray, sphere);

		if (sphere_hit.x < intersection.t && min_t < sphere_hit.x && sphere_hit.x < max_t) {
			intersection.t = sphere_hit.x;
			intersection.sphere = sphere;
		}
		if (sphere_hit.y < intersection.t && min_t < sphere_hit.y && sphere_hit.y < max_t) {
			intersection.t = sphere_hit.y;
			intersection.sphere = sphere;
		}
	}

    for (int i = 0; i < scene.triangles_num; i++) {
		Triangle triangle = triangles[i];

		vec2 triangle_hit = getTriangleHit(ray, triangle);

		if (triangle_hit.x < intersection.t && min_t < triangle_hit.x && triangle_hit.x < max_t) {
			intersection.t = triangle_hit.x;
			intersection.triangle = triangle;
            intersection.is_triangle = true;
		}
		if (triangle_hit.y < intersection.t && min_t < triangle_hit.y && triangle_hit.y < max_t) {
			intersection.t = triangle_hit.y;
			intersection.triangle = triangle;
            intersection.is_triangle = true;
		}
	}

	return intersection;
}

vec3 getSphereNormal(vec3 point, Sphere sphere) {
    return normalize(point - sphere.center.xyz);
}

vec3 getTriangleNormal(Triangle triangle) {
    vec4 AB = triangle.B - triangle.A;
    vec4 AC = triangle.C - triangle.A;

    vec3 normal = normalize(cross(AB.xyz, AC.xyz));

    return normal;
}

const float light_size = 0.025;
const vec3 offsets[8] = {
  vec3(-light_size, -light_size, -light_size),
  vec3(light_size, -light_size, -light_size),
  vec3(light_size, light_size, -light_size),
  vec3(-light_size, light_size, -light_size),
  vec3(-light_size, -light_size, light_size),
  vec3(light_size, -light_size, light_size),
  vec3(light_size, light_size, light_size),
  vec3(-light_size, light_size, light_size)
};

float getShadow(
    vec3 point,
    vec3 normal,
    PointLight point_light
) {
    float intensity = 0.0f;

    for(int i = 0; i < 8; i++) {
        vec3 light_point = point + offsets[i];

        vec3 light_vector = GetPointLightVector(light_point, point_light);

        Ray shadow_ray;
        shadow_ray.origin = point + EPSILON * normal;
        shadow_ray.direction = light_vector;
        Hit shadow_blocker = getIntersection(shadow_ray, EPSILON, distance(light_point, point_light.position.xyz));
	    
        if (shadow_blocker.t != INFINITY) {
		    intensity += 1.0f;
	    }
    }

    intensity /= 8;

    return intensity;
}

vec3 ComputeLight(
    vec3 point,
    vec3 normal,
    vec3 view,
    Hit intersection
) {
    float bright = 0.0f;
    float length_n = length(normal);
    float length_v = length(view);
    vec3 final_color = vec3(0.0f);
    vec3 light_color = vec3(1.0f); 

    vec3 obj_color;
    float obj_specular;

    if (!intersection.is_triangle) {
        obj_color = intersection.sphere.color.xyz;
        obj_specular = intersection.sphere.specular;
    } else {
        obj_color = intersection.triangle.color.xyz;
        obj_specular = intersection.triangle.specular;
    }

    for (int i = 0; i < scene.point_lights_num; i++) {
        PointLight point_light = point_lights[i];

        vec3 lightVector = GetPointLightVector(point, point_light);

        float shadow_intensity = getShadow(point, normal, point_light);

        vec3 diffuse_color = light_color * max(dot(normal, lightVector), 0.0f) * point_light.bright;

        vec3 specular_color = vec3(0.0);

        if (obj_specular != -1.0f) {
            vec3 reflected = -reflect(lightVector, normal);
            float r_dot_v = max(dot(reflected, view), 0.0f);
            float specular_strength = pow(r_dot_v, point_light.shininess);

            specular_color = obj_specular * specular_strength * light_color;
        }

        final_color += (1.0 - shadow_intensity) * (diffuse_color + specular_color) * obj_color;
    }

    return final_color;
}

vec3 traceRay(
    Ray ray,
    float min_t,
    float max_t,
    int reflection_depth
) {
    vec3 final_color = vec3(0.0);
    float reflection_intensity = 1.0;

    for (int i = 0; i < reflection_depth; i++) {
        Hit intersection = getIntersection(ray, min_t, max_t);

        if (intersection.t == INFINITY) {
            // final_color += reflection_intensity * getSkyColor(ray);
            final_color += reflection_intensity * vec3(0.0f, 0.0f, 0.0f);
            break;
        }

        vec3 point = ray.origin + (ray.direction * intersection.t);
        vec3 normal;

        if (!intersection.is_triangle) {
            normal = getSphereNormal(point, intersection.sphere);
        } else {
            normal = getTriangleNormal(intersection.triangle);
        }

        vec3 view = ray.direction * -1.0;

        vec3 local_color = ComputeLight(point, normal, view, intersection);

        final_color += reflection_intensity * local_color;

        float reflective;
        if (!intersection.is_triangle) {
            reflective = intersection.sphere.reflective;
        } else {
            reflective = intersection.triangle.reflective;
        }

        if (reflective > 0.0f) {
            ray.origin = point + EPSILON * normal;
            ray.direction = normalize(reflect(ray.direction, normal));
            reflection_intensity *= reflective;
        } else {
            break;
        }
    }

    return final_color;
}

vec3 getPixelColor(float x, float y)
{
    Ray ray = getRay(x, y);

    vec3 color = traceRay(ray, 1, INFINITY, 3);

    return color;
}


vec3 perPixel(int x, int y)
{
	// anti-aliasing
	float half_aa = scene.aa / 2.0f;
	float partial_aa = 1.f / half_aa;

    vec3 color = vec3(0.0f);

    float pixel_start_x = x - 0.5f;
	float pixel_start_y = y - 0.5f;

    for (int i = 0; i < half_aa; i++) {
		float u = pixel_start_x + (partial_aa * i);
		float v = pixel_start_y + (partial_aa * i);

		color = color + getPixelColor(u, v);
	}

	pixel_start_x = x + 0.5f;

    for (int i = 0; i < half_aa; i++) {
	    float u = pixel_start_x - (partial_aa * i);
		float v = pixel_start_y + (partial_aa * i);

		color = color + getPixelColor(u, v);
	}

	vec3 result_ns = color / scene.aa;

    return result_ns;
}